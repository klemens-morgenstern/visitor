<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE library PUBLIC "-//Boost//DTD BoostBook XML V1.0//EN"
  "http://www.boost.org/tools/boostbook/dtd/boostbook.dtd">
<!--
    Copyright 2015, Klemens Morgenstern

    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-->
<section id="visitor.tutorial.poly">
  <title>Polymorhpic Visitors</title>

<using-namespace name="boost"/>
<using-class name="boost::polymorphic_visitor"/>

<para>The <code>static_visitor</code> is resolved at compile time. It may however
be necessary to implement a run-time resolved visitor. Therefore a class template is provided,
<code>boost::polymorphic_visitor</code>. This class provides nothing more than an abstract interface
and is declared straight-forward:
<programlisting>
typedef polymorphic_visitor&lt;void, int, double&gt; poly_vis;
</programlisting> 
This declaration provides a polymorphic visitor, which has two operators, 
one for <code>int</code> and one for <code>double</code>, which return <code>void</code>.
</para>
<para>
If more then one argument shall be used by one operator, they must be put into the
given template <code>boost::arg_tuple</code>.
<programlisting>
typedef polymorphic_visitor&lt;int, arg_tuple&lt;int, int &gt;arg_tuple&lt;double, double&gt;&gt;; 
</programlisting>
This declares a visitor, which either takes two <code>int</code> or two <code>double</code>.
</para>
</section>
<section id="visitor.tutorial.poly_adapt">
  <title>Polymorhpic Visitor Adaptation</title>

<using-namespace name="boost"/>
<using-class name="boost::polymorphic_visitor_adapt"/>
<para>The example given above only declares interfaces, which can be overloaded by hand.
The library does however provide a solution to adapt a static visitor into a polymorphic one.
<programlisting>
auto vis = make_functor_visitor(
	std::add&lt;int&gt;(),
	std::negate&lt;int&gt;());

typedef polymorphic_visitor&lt;int, arg_tuple&lt;int, int&gt;&gt; poly_vis;	

auto adapted = adapt_polymorphic_visitor&lt;poly_vis&gt;(vis);
/* the type of adapted is polymorphic_visitor_adapt&ltdecltype(vis), poly_vis&gt;
 * which of course inhertis poly_vis.
 * /
</programlisting>
This way a <code>static_visitor</code> can be passed as an polymorphic visitor very easily.
The <code>static_visitor</code> is hold by reference inside the adaptation structure. 	
</para>

</section>

<section id="visitor.tutorial.poly_deduct">
  <title>Polymorhpic Visitor Deduction</title>

<using-namespace name="boost"/>
<using-class name="boost::polynomic_visitor_deduction"/>
<para>It is also possible to deduce such an interface from a variant. 
This is done via the template <code>polynomic_visitor_deduction</code>. 
It needs the return type as the first parameters.
<programlisting>
typedef variant&lt;int, double&gt; var;
typedef polynomic_visitor_deduction&lt;double, var&gt; vis_if;
//vis_if type is polymorphic_visitor&lt;int, doble&gt;;
</programlisting>
Since <code>boost::variant</code> allows multivisitation, the necessary visitors can also be deduced, 
by passing several variants.
<programlisting>
typedef variant&lt;int,    double&gt; var1;
typedef variant&lt;string, int&gt; var2;
typedef polynomic_visitor_deduction&lt;double, var1, var2&gt; vis_if;
/*vis_if type is polymorphic_visitor&lt;
	arg_tuple&lt;int, double&gt;,
	arg_tuple&lt;int, string&gt;,
	arg_tuple&lt;double, double&gt;,
	arg_tuple&lt;double, string&gt;,
	&gt;;
</programlisting> 
</para>
</section>






